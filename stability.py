import numpy as np
from matplotlib import pyplot as plt
from scipy.integrate import trapz
from wings import fusGeometry as fusgeom
from wings import wingGeometry as winggeom
from sympy import symbols, Eq, solve
from wings import air_density
from wings import true_airspeed_at_altitude

print("--------------------------------------------------------------------------------")
#values to calculate the coefficients 
rho = air_density(12500)[0]
speed = true_airspeed_at_altitude(12500)

#CL for equilibrium 
Cl_tot = 0
CL_T = 1.76

#Important general values 
MAC_tot = 9.949 
surf_tot = 182.56
AR_tot = 1.5
b = 29
MAC_tail = 1.483
hor_tail_surf = 3.182
a = 1.754
a1 = 1.5
a1_over_a = a1/a
weight = 471511.49122

#Calculation of the Cm0_tot ==> separate the integral in to parts
Cm0_airfoil_fus = -0.1158 
Cm0_airfoil_wing = -0.1533

_, _, _, _, _, _, _, _, y_wing, leading_wing, trailing_wing, quarter_wing = winggeom() 
_, _, _, _, _, _, _, y_fus, leading_fus, trailing_fus, quarter_fus = fusgeom() 
c_fus = trailing_fus - leading_fus
c_wing = trailing_wing - leading_wing

Cm0_wing = (2/(surf_tot*MAC_tot)) * trapz(Cm0_airfoil_wing*c_wing**2, y_wing)
Cm0_fus = (2/(surf_tot*MAC_tot)) * trapz(Cm0_airfoil_fus*c_fus**2, y_fus)
Cm0_tot = Cm0_wing + Cm0_fus

print("The blended wing body has a Cm0_tot of",Cm0_tot)

#Position of the important points

x_CG_tot = 9.5
x_AC_tot = 8.789
z_AC_tot = 0

x_AC_tail = 16.5
z_AC_tail = 1.51

#tail volume ratio effectivness 
V_T = hor_tail_surf * (x_AC_tail - x_CG_tot)/(surf_tot* MAC_tot)


##################################################################
######EQUILIBRIUM IN PITCH
##################################################################


def CL(): 
    L_tot, L_T = symbols('L_tot L_T')
    Cm_T = V_T * CL_T

    Cm_tot = Cm0_tot + Cl_tot* (x_CG_tot - x_AC_tot)/MAC_tot - Cm_T
    #translation equilibrium 
    eq1 = Eq(L_tot + L_T - weight,0)
    
    #rotation equilibrium 
    eq2 = Eq(Cm0_tot + L_tot*(x_CG_tot-x_AC_tot)/(1/2*rho*speed**2 * MAC_tot*surf_tot)-L_T*(x_AC_tail - x_CG_tot)/(1/2*rho*speed**2 * MAC_tail*hor_tail_surf)*V_T,0)

    solution = solve((eq1,eq2),(L_tot,L_T))
    L_tot = solution[L_tot]
    L_T = solution[L_T]

    CL_tot = L_tot/(1/2*rho*speed**2 * surf_tot)
    CL_tail = L_T/(1/2*rho*speed**2 * hor_tail_surf)
   
    return L_tot,L_T,CL_tot, CL_tail

print("----------------------------------------------------------------------")
print("The new lift force generated by the body is",CL()[0],"[N]")
print("The new lift force generated by the tail is",CL()[1],"[N]")
print("The new lift coefficient generated by the body is",CL()[2],"[-]")
print("The new lift coefficient generated by the tail is",CL()[3],"[-]")
print("----------------------------------------------------------------------")

def downwash():
    Cl_tot = CL()[2]
    deps = 2*a/(np.pi*AR_tot)
    eps = 2*Cl_tot/(np.pi*AR_tot)
    return eps, deps

eps = downwash()
print("The downwash effect eps equals", eps[0]," and deps/dalpha is equal to", eps[1])


##################################################################
######LONGITUDINAL STATIC STABILITY
##################################################################

def long_stat_stab(): #in the pitching plane
    #check the stability
    #neutral point : position of the cg in order to have the derivative equals 0
    deps = downwash()[1]
    
    hn = x_AC_tot/MAC_tot + V_T*a1_over_a*(1- deps) #- 0.5*fus_width**2 * fus_length/(S_wing*a*MAC_wing)#position of the neutral point  

    derivative = hn - x_CG_tot/MAC_tot 
    Kn = - derivative #static margin

    if Kn >= 0.05 and Kn < 0.2 : 
        print("The static margin has a correct value and is equal to : ", (Kn*100), "%")

    else : 
        print("The static margin has to be changed and is equal to : ", (Kn*100), "%")
    
    return 

long_stat_stab()
##################################################################
######LATERAL STATIC STABILITY
##################################################################

def yaw_stab(): #stable if dCn/dbeta < 0

    return 

"""
def downwash():
    It = x_AC_tail - x_AC_tot
    lamb = 0.086190476 #global taper ratio 
    m = (z_AC_tail - z_AC_tot)/b*2 #because (z_AC_tail - z_AC_wing) = mb/2

    print("m is equal to",m)
    
    deps = (1.75*a)/(np.pi*AR_tot*(((2*lamb*It)/b)**1.4)*(1 + np.abs(m)))
    
    return deps

eps = downwash()
print("deps/dalpha is equal to", eps)
"""